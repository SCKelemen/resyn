INSTANTIATE <a> . {List {1**a||0}|_v == (Nil)|0}
INTO {List {1**A0||0}|_v == (Nil)|0}
INSTANTIATE <a> . x:{1**a||0} -> xs:{List {1**a||0}||0} -> {List {1**a||0}|_v == (Cons x xs)|0}
INTO y:{1**A1||0} -> ys:{List {1**A1||0}||0} -> {List {1**A1||0}|_v == (Cons y ys)|0}

 
 Checking xs :: {List {1**A0||0}||0} in
\xs . 
  match ?? with
from env with top-level potentials: Emptyset : 0,Nil : 0,xs : 0 fp2
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs |- {List {m0**a||0}|_v == xs|0} <: {List {1**A0||0}||0}
    Emptyset Nil xs ~ Emptyset Nil xs fp2
    Emptyset Nil xs 0 \/
    Emptyset Nil xs 0 || Emptyset Nil xs 0
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs |- 0 \/ fp0 || fp1
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs |- {1**A1||0}
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs |- {1**A0||0}
UNIFY A0 WITH {m0**a||0} PRODUCING {m0**a|U0|0}
Type assignment
  A0 -> {m0**a|U0|0}
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs |- {1**A1||0}
Type assignment
  A0 -> {m0**a|U0|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs |- {m0**a||0} <: {m0**a|U0|0}
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs |- {List|False|0} <: {List||0}
    Emptyset Nil xs ~ Emptyset Nil xs fp2
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs |- 1 \/ m0 || m1
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs |- 0 \/ fp0 || fp1
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs |- {m0**a|U0|0}
Constraints
  False ==> True
  True ==> U0
QMap
  U0 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}] (2 0)
Remaining Candidates (1)
  0: [U0 -> {}] (2 0)

Generating resource constraints:
  Emptyset Nil xs ~ Emptyset Nil xs ~>
    (((((0 + fp0) + 0 == (0 + fp2) + 0 && fp0 >= 0) && fp2 >= 0) && 0 >= 0) && 0 >= 0) && 0 >= 0
  1 \/ m0 || m1 ~>
    ((1 >= 0 && m0 >= 0) && m1 >= 0) && 1 == m0 + m1
  0 \/ fp0 || fp1 ~>
    ((0 >= 0 && fp0 >= 0) && fp1 >= 0) && 0 == fp0 + fp1
Solved with model
m1IntS -> 1
m0IntS -> 0
fp2IntS -> 0
fp1IntS -> 0
fp0IntS -> 0

Accumulated resource constraints:
    []
Solved resource constraint after conjoining formulas: SAT
    (and (= (+ 0 fp0IntS 0) (+ 0 fp2IntS 0))
     (>= fp0IntS 0)
     (>= fp2IntS 0)
     (>= 0 0)
     (>= 0 0)
     (>= 0 0))
    (and (>= 1 0) (>= m0IntS 0) (>= m1IntS 0) (= 1 (+ m0IntS m1IntS)))
    (and (>= 0 0) (>= fp0IntS 0) (>= fp1IntS 0) (= 0 (+ fp0IntS fp1IntS)))
Matching constructor type
{List {0**A0||0}|_v == (Nil)|0}
with scrutinee
{List {m0**a||0}|_v == xs|0}

 
 Checking xs :: {List {1**a||0}||0} in
\xs . 
  match xs with
    Nil -> ??
from env with top-level potentials: Emptyset : 0,Nil : 0,xs : 0 fp3
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs xs == (Nil) |- {List {m1**a||0}|_v == xs|0} <: {List {1**a||0}||0}
    Emptyset Nil xs ~ Emptyset Nil xs fp3
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs |- {1**A1||0}
Type assignment
  A0 -> {m0**a||0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs xs == (Nil) |- {m1**a|False|0} <: {1**a||0}
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs xs == (Nil) |- {List|False|0} <: {List||0}
    Emptyset Nil xs ~ Emptyset Nil xs fp3
Constraints
  False ==> True
  False ==> True
QMap
  U0 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}] (2 0)
Remaining Candidates (1)
  0: [U0 -> {}] (2 0)

Generating resource constraints:
  Emptyset Nil xs ~ Emptyset Nil xs ~>
    (((((0 + fp1) + 0 == (0 + fp3) + 0 && fp1 >= 0) && fp3 >= 0) && 0 >= 0) && 0 >= 0) && 0 >= 0
Solved with model
fp3IntS -> 0
m1IntS -> 0
m0IntS -> 1
fp2IntS -> 0
fp1IntS -> 0
fp0IntS -> 0

Accumulated resource constraints:
    [(and (= (+ 0 fp0IntS 0) (+ 0 fp2IntS 0))
     (>= fp0IntS 0)
     (>= fp2IntS 0)
     (>= 0 0)
     (>= 0 0)
     (>= 0 0))
    ,(and (>= 1 0) (>= m0IntS 0) (>= m1IntS 0) (= 1 (+ m0IntS m1IntS)))
    ,(and (>= 0 0) (>= fp0IntS 0) (>= fp1IntS 0) (= 0 (+ fp0IntS fp1IntS)))]
Solved resource constraint after conjoining formulas: SAT
    (and (= (+ 0 fp1IntS 0) (+ 0 fp3IntS 0))
     (>= fp1IntS 0)
     (>= fp3IntS 0)
     (>= 0 0)
     (>= 0 0)
     (>= 0 0))
Matching constructor type
{List {1**A1||0}|_v == (Cons y ys)|0}
with scrutinee
{List {m0**a||0}|_v == xs|0}
INSTANTIATE <a> . x0:{List {1**a||0}|len _v >= 0 && len _v < len xs|0} -[1]-> {List {1**a||0}||0}
INTO x3:{List {1**A2||0}|len _v >= 0 && len _v < len xs|0} -[1]-> {List {1**A2||0}||0}

 
 Checking simple :: x2:_ -> {List {1**a||0}||0} in
\xs . 
  match xs with
    Cons y ys -> ?? ??
from env with top-level potentials: Emptyset : 0,Nil : 0,xs : 0,y : 0,ys : 0 fp7
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs, y, ys xs == (Cons y ys) |- x3:{List {1**A2||0}|len _v >= 0 && len _v < len xs|0} -[1]-> {List {1**A2||0}||0} /\ x2:_ -> {List {1**a||0}||0}
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs, y, ys xs == (Cons y ys) |- x3:{List {1**A2||0}|len _v >= 0 && len _v < len xs|0} -[1]-> {List {1**A2||0}||0} <: x2:_ -> {List {1**a||0}||0}
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs, y, ys xs == (Cons y ys) |- x3:{List {1**A2||0}||0} -> {List {1**A2|False|0}|False|0} <: xs:{List {1**a|False|0}|False|0} -> {List {1**a||0}||0}
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs, y, ys |- {1**A2||0}
    Emptyset Nil xs y ys fp5 \/
    Emptyset Nil xs y ys 0 || Emptyset Nil xs y ys 0
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs, y, ys xs == (Cons y ys) |- fp5 \/ fp7 || fp8
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs, y, ys xs == (Cons y ys) |- fp4 \/ fp5 || fp6
    Emptyset Nil xs y ys ~ Emptyset Nil xs y ys fp4
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs |- {1**A1||0}
UNIFY A2 WITH {1**a||0} PRODUCING {1**a|U1|0}
Type assignment
  A0 -> {m0**a||0}
  A1 -> {m0**a||0}
  A2 -> {1**a|U1|0}
Typing Constraints
Type assignment
  A0 -> {m0**a||0}
  A1 -> {m0**a||0}
  A2 -> {1**a|U1|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, simple, x2, xs, y, ys xs == (Cons y ys) |- {1**a|False|0} <: {1**a||0}
    Cons, Emptyset, Insert, Nil, Singleton, simple, x2, xs, y, ys xs == (Cons y ys) |- {List|False|0} <: {List||0}
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs, y, ys xs == (Cons y ys) |- {1**a|False|0} <: {1**a|U1|0}
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs, y, ys xs == (Cons y ys) |- {List|False|0} <: {List||0}
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs, y, ys xs == (Cons y ys) |- {1**a|False|0} <: {1**a||0}
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs, y, ys xs == (Cons y ys) |- {List|False|0} <: {List||0}
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs, y, ys |- {1**a|U1|0}
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs, y, ys xs == (Cons y ys) |- m1 \/ m2 || m5
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs, y, ys xs == (Cons y ys) |- m0 \/ m3 || m6
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs, y, ys xs == (Cons y ys) |- m0 \/ m4 || m7
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs, y, ys xs == (Cons y ys) |- fp5 \/ fp7 || fp8
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs, y, ys xs == (Cons y ys) |- fp4 \/ fp5 || fp6
    Emptyset Nil xs y ys ~ Emptyset Nil xs y ys fp4
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs |- {m0**a||0}
Constraints
  False ==> True
  False ==> True
  False ==> True
  False ==> U1
  False ==> True
  False ==> True
QMap
  U0 -> {}
  U1 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}, U1 -> {}] (3 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}] (3 0)

Generating resource constraints:
  m1 \/ m2 || m5 ~>
    ((m1 >= 0 && m2 >= 0) && m5 >= 0) && m1 == m2 + m5
  m0 \/ m3 || m6 ~>
    ((m0 >= 0 && m3 >= 0) && m6 >= 0) && m0 == m3 + m6
  m0 \/ m4 || m7 ~>
    ((m0 >= 0 && m4 >= 0) && m7 >= 0) && m0 == m4 + m7
  fp5 \/ fp7 || fp8 ~>
    ((fp5 >= 0 && fp7 >= 0) && fp8 >= 0) && fp5 == fp7 + fp8
  fp4 \/ fp5 || fp6 ~>
    ((fp4 >= 0 && fp5 >= 0) && fp6 >= 0) && fp4 == fp5 + fp6
  Emptyset Nil xs y ys ~ Emptyset Nil xs y ys ~>
    (((((((0 + fp1) + 0 == (0 + fp4) + 0 && fp1 >= 0) && fp4 >= 0) && 0 >= 0) && 0 >= 0) && 0 >= 0) && 0 >= 0) && 0 >= 0
Solved with model
m3IntS -> 0
fp7IntS -> 0
m1IntS -> 1
fp2IntS -> 0
fp1IntS -> 0
fp3IntS -> 0
fp4IntS -> 0
m4IntS -> 0
fp0IntS -> 0
m7IntS -> 0
fp8IntS -> 0
m2IntS -> 1
m5IntS -> 0
fp5IntS -> 0
fp6IntS -> 0
m0IntS -> 0
m6IntS -> 0

Accumulated resource constraints:
    [(and (= (+ 0 fp0IntS 0) (+ 0 fp2IntS 0))
     (>= fp0IntS 0)
     (>= fp2IntS 0)
     (>= 0 0)
     (>= 0 0)
     (>= 0 0))
    ,(and (>= 1 0) (>= m0IntS 0) (>= m1IntS 0) (= 1 (+ m0IntS m1IntS)))
    ,(and (>= 0 0) (>= fp0IntS 0) (>= fp1IntS 0) (= 0 (+ fp0IntS fp1IntS)))
    ,(and (= (+ 0 fp1IntS 0) (+ 0 fp3IntS 0))
     (>= fp1IntS 0)
     (>= fp3IntS 0)
     (>= 0 0)
     (>= 0 0)
     (>= 0 0))]
Solved resource constraint after conjoining formulas: SAT
    (and (>= m1IntS 0) (>= m2IntS 0) (>= m5IntS 0) (= m1IntS (+ m2IntS m5IntS)))
    (and (>= m0IntS 0) (>= m3IntS 0) (>= m6IntS 0) (= m0IntS (+ m3IntS m6IntS)))
    (and (>= m0IntS 0) (>= m4IntS 0) (>= m7IntS 0) (= m0IntS (+ m4IntS m7IntS)))
    (and (>= fp5IntS 0)
     (>= fp7IntS 0)
     (>= fp8IntS 0)
     (= fp5IntS (+ fp7IntS fp8IntS)))
    (and (>= fp4IntS 0)
     (>= fp5IntS 0)
     (>= fp6IntS 0)
     (= fp4IntS (+ fp5IntS fp6IntS)))
    (and (= (+ 0 fp1IntS 0) (+ 0 fp4IntS 0))
     (>= fp1IntS 0)
     (>= fp4IntS 0)
     (>= 0 0)
     (>= 0 0)
     (>= 0 0)
     (>= 0 0)
     (>= 0 0))

 
 Checking ys :: {List {1**A2||0}|len _v >= 0 && len _v < len xs|1 + -(fp6 + 0)} in
\xs . 
  match xs with
    Cons y ys -> simple ??
from env with top-level potentials: Emptyset : 0,Nil : 0,xs : 0,y : 0,ys : 0 fp8
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs, y, ys xs == (Cons y ys) |- {List {m7**a||0}|_v == ys|0} <: {List {1**A2||0}|len _v >= 0 && len _v < len xs|1 + -(fp6 + 0)}
stripping int: IntLit 0
stripping bin: Binary Plus (IntLit 1) (Unary Neg (Binary Plus (Var IntS "fp6") (IntLit 0)))
stripping int: IntLit 1
stripping unary: Unary Neg (Binary Plus (Var IntS "fp6") (IntLit 0))
stripping bin: Binary Plus (Var IntS "fp6") (IntLit 0)
stripping var: Var IntS "fp6"
stripping int: IntLit 0
Type assignment
  A0 -> {m0**a||0}
  A1 -> {m0**a||0}
  A2 -> {1**a|U1|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, _v, simple, xs, y, ys xs == (Cons y ys) |- 0 >= 1 + -(fp6 + 0)
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs, y, ys xs == (Cons y ys) |- {m7**a||0} <: {1**a|U1|0}
    Cons, Emptyset, Insert, Nil, Singleton, simple, xs, y, ys xs == (Cons y ys) |- {List|_v == ys|0} <: {List|len _v >= 0 && len _v < len xs|0}
Constraints
  ((_v == ys && xs == (Cons y ys)) && len xs >= 0) && len ys >= 0 ==> len _v >= 0 && len _v < len xs
  (xs == (Cons y ys) && len xs >= 0) && len ys >= 0 ==> U1
QMap
  U0 -> {}
  U1 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}, U1 -> {}] (5 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}] (5 0)

Generating resource constraints:
  0 >= 1 + -(fp6 + 0) ~>
    0 >= 1 + -(fp6 + 0)
Accumulated resource constraints:
    [(and (= (+ 0 fp0IntS 0) (+ 0 fp2IntS 0))
     (>= fp0IntS 0)
     (>= fp2IntS 0)
     (>= 0 0)
     (>= 0 0)
     (>= 0 0))
    ,(and (>= 1 0) (>= m0IntS 0) (>= m1IntS 0) (= 1 (+ m0IntS m1IntS)))
    ,(and (>= 0 0) (>= fp0IntS 0) (>= fp1IntS 0) (= 0 (+ fp0IntS fp1IntS)))
    ,(and (= (+ 0 fp1IntS 0) (+ 0 fp3IntS 0))
     (>= fp1IntS 0)
     (>= fp3IntS 0)
     (>= 0 0)
     (>= 0 0)
     (>= 0 0))
    ,(and (>= m1IntS 0) (>= m2IntS 0) (>= m5IntS 0) (= m1IntS (+ m2IntS m5IntS)))
    ,(and (>= m0IntS 0) (>= m3IntS 0) (>= m6IntS 0) (= m0IntS (+ m3IntS m6IntS)))
    ,(and (>= m0IntS 0) (>= m4IntS 0) (>= m7IntS 0) (= m0IntS (+ m4IntS m7IntS)))
    ,(and (>= fp5IntS 0)
     (>= fp7IntS 0)
     (>= fp8IntS 0)
     (= fp5IntS (+ fp7IntS fp8IntS)))
    ,(and (>= fp4IntS 0)
     (>= fp5IntS 0)
     (>= fp6IntS 0)
     (= fp4IntS (+ fp5IntS fp6IntS)))
    ,(and (= (+ 0 fp1IntS 0) (+ 0 fp4IntS 0))
     (>= fp1IntS 0)
     (>= fp4IntS 0)
     (>= 0 0)
     (>= 0 0)
     (>= 0 0)
     (>= 0 0)
     (>= 0 0))]
Solved resource constraint after conjoining formulas: UNSAT
    (>= 0 (+ 1 (- (+ fp6IntS 0))))
TYPE ERROR: Insufficient resources
when checking ys ::
{List {1**a||0}|len _v >= 0 && len _v < len xs|1 + -(fp6 + 0)}
in
\xs . 
  match xs with
    Cons y ys -> simple ys
