data List a <q :: Int> where
  Nil  :: List a <q>
  Cons :: x:a -> xs: List {a | | q} <q> -> List a <q>

data Tree a <q :: Int> where
  Leaf :: x:a -> Tree a <q>
  Node :: l: { Tree {a | | q} <q> | | q}
       -> r: Tree {a | | q} <q> 
       -> Tree a <q>

merge :: List {a | | 1} <{0}> -> List {a | | 1} <{0}> -> List a <{0}>
merge = \xs. \ys. 
  match xs with
    Nil        -> ys
    Cons xh xt -> match ys with
                    Nil        -> xs
                    Cons yh yt -> if xh < yh
                                    then Cons xh (tick 1 (merge xt (Cons yh yt)))
                                    else Cons yh (tick 1 (merge (Cons xh xt) yt))

--takes the contents of a tree and arranges them in a sorted list
flatten :: Tree {a | | 1} <{3}> -> List a <{0}>
flatten = \t. 
  match t with
    Leaf x -> Cons x Nil
    Node l r -> tick 1 (merge (tick 1 (flatten l)) (tick 1 (flatten r)))
