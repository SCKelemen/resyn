INSTANTIATE <a> . {List {1**a||0}|_v == (Nil)|0}
INTO {List {1**A0||0}|_v == (Nil)|0}
INSTANTIATE <a> . x:{1**a||0} -> xs:{List {1**a||0}||0} -> {List {1**a||0}|_v == (Cons x xs)|0}
INTO x:{1**A1||0} -> xs:{List {1**A1||0}||0} -> {List {1**A1||0}|_v == (Cons x xs)|0}

 
 Checking arg0 :: {List {1**A0||0}||0} in
\arg0 . 
  match ?? with
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : 0 fp2
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len |- {List {m0**a||p1}|_v == arg0|p4} <: {List {1**A0||0}||0}
    Emptyset Nil arg0 ~ Emptyset Nil arg0 fp2
    Shared scalars: Emptyset Nil arg0 0 \/
    Emptyset Nil arg0 fp0 || Emptyset Nil arg0 fp1
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len |- {1**A1||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len |- {1**A0||0}
UNIFY A0 WITH {m0**a||p1} PRODUCING {m0**a|U0|p1}
stripping var: Var IntS "p1"
stripping var: Var IntS "p1"
Type assignment
  A0 -> {m0**a|U0|p1}
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len |- {1**A1||0}
Type assignment
  A0 -> {m0**a|U0|p1}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len |- p1 >= p1
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len |- {m0**a||0} <: {m0**a|U0|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len |- {List|False|p4} <: {List||0}
    Emptyset Nil arg0 ~ Emptyset Nil arg0 fp2
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len |- 0 \/ fp0 || fp1
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len |- 0 \/ p0 || p2
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len |- 0 \/ p1 || p3
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len |- 1 \/ m0 || m1
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len |- {m0**a|U0|p1}
Constraints
  False ==> True
  True ==> U0
QMap
  U0 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}] (2 0)
Remaining Candidates (1)
  0: [U0 -> {}] (2 0)
Matching constructor type
{List {0**A0||0}|_v == (Nil)|0}
with scrutinee
{List {m0**a||p1}|_v == arg0|p4}

 
 Checking 0 :: {Int|_v >= 0|0} in
\arg0 . 
  match arg0 with
    Nil -> ??
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : p5 fp3
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len arg0 == (Nil) |- {Int|_v == 0|0} <: {Int|_v >= 0|0}
    Emptyset Nil arg0 ~ Emptyset Nil arg0 fp3
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len |- {1**A1||0}
Type assignment
  A0 -> {m0**a||p1}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len arg0 == (Nil) |- {Int|_v == 0|0} <: {Int|_v >= 0|0}
    Emptyset Nil arg0 ~ Emptyset Nil arg0 fp3
Constraints
  (_v == 0 && arg0 == (Nil)) && len arg0 >= 0 ==> _v >= 0
QMap
  U0 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}] (3 0)
Remaining Candidates (1)
  0: [U0 -> {}] (3 0)
Matching constructor type
{List {1**A1||0}|_v == (Cons x xs)|0}
with scrutinee
{List {m0**a||p1}|_v == arg0|p4}
INSTANTIATE x:{Int||0} -> y:{Int||0} -> {Int|_v == x + y|0}
INTO x3:{Int||0} -> x4:{Int||0} -> {Int|_v == x3 + x4|0}

 
 Checking + :: x2:_ -> x1:_ -> {Int|_v >= 0|0} in
\arg0 . 
  match arg0 with
    Cons x xs -> ?? ?? ??
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : p19,x : p21,xs : p22 fp11
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- x3:{Int||0} -> x4:{Int||0} -> {Int|_v == x3 + x4|0} /\ x2:_ -> x1:_ -> {Int|_v >= 0|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- x3:{Int||0} -> x4:{Int||0} -> {Int|_v == x3 + x4|0} <: x2:_ -> x1:_ -> {Int|_v >= 0|0}
    Shared scalars: Emptyset Nil arg0 x xs fp9 \/
    Emptyset Nil arg0 x xs fp11 || Emptyset Nil arg0 x xs fp12
    Shared scalars: fp7 \/
    fp9 || fp10
    Shared scalars: Emptyset Nil arg0 x xs fp5 \/
    Emptyset Nil arg0 x xs fp7 || Emptyset Nil arg0 x xs fp8
    Shared scalars: fp4 \/
    fp5 || fp6
    Emptyset Nil arg0 x xs ~ Emptyset Nil arg0 x xs fp4
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len |- {1**A1||0}
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, x3, x4, xs arg0 == (Cons x xs) |- {Int|_v == x3 + x4|0} /\ {Int|_v >= 0|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, x1, x2, xs arg0 == (Cons x xs) |- {Int|_v == x2 + x1|0} <: {Int|_v >= 0|0}
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- fp9 \/ fp11 || fp12
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len, x, xs arg0 == (Cons x xs) |- p9 \/ p19 || p24
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len, x, xs arg0 == (Cons x xs) |- p10 \/ p20 || p25
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- m2 \/ m8 || m11
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len, x, xs arg0 == (Cons x xs) |- p11 \/ p21 || p26
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- m3 \/ m9 || m12
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len, x, xs arg0 == (Cons x xs) |- p12 \/ p22 || p27
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len, x, xs arg0 == (Cons x xs) |- p13 \/ p23 || p28
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- m4 \/ m10 || m13
    Shared potential: |- fp7 \/ fp9 || fp10
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- fp5 \/ fp7 || fp8
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len, x, xs arg0 == (Cons x xs) |- p6 \/ p9 || p14
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len, x, xs arg0 == (Cons x xs) |- p3 \/ p10 || p15
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- m1 \/ m2 || m5
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len, x, xs arg0 == (Cons x xs) |- p7 \/ p11 || p16
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- m0 \/ m3 || m6
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len, x, xs arg0 == (Cons x xs) |- p8 \/ p12 || p17
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len, x, xs arg0 == (Cons x xs) |- p1 \/ p13 || p18
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- m0 \/ m4 || m7
    Shared potential: |- fp4 \/ fp5 || fp6
    Emptyset Nil arg0 x xs ~ Emptyset Nil arg0 x xs fp4
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len |- {m0**a||p1}
Constraints
  False ==> _v >= 0
QMap
  U0 -> {}
Checking consistency
  (((_v == x3 + x4 && arg0 == (Cons x xs)) && _v >= 0) && len arg0 >= 0) && len xs >= 0
Candidates (1)
  0: [U0 -> {}] (4 0)
Remaining Candidates (1)
  0: [U0 -> {}] (4 0)

 
 Checking 1 :: {Int||fp10} in
\arg0 . 
  match arg0 with
    Cons x xs -> ?? + ??
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : p24,x : p26,xs : p27 fp12
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- {Int|_v == 1|0} <: {Int||fp10}
stripping int: IntLit 0
stripping var: Var IntS "fp10"
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len, x, xs arg0 == (Cons x xs) |- 0 >= fp10
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- {Int|False|0} <: {Int||0}
Constraints
  False ==> True
QMap
  U0 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}] (4 0)
Remaining Candidates (1)
  0: [U0 -> {}] (4 0)

 
 Checking +
            1 :: x1:_ -> {Int|_v >= 0|0} in
\arg0 . 
  match arg0 with
    Cons x xs -> ?? ??
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : p9,x : p11,xs : p12 fp7
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- x4:{Int||0} -> {Int|_v == 1 + x4|0} /\ x1:_ -> {Int|_v >= 0|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- x4:{Int||0} -> {Int|_v == 1 + x4|0} <: x1:_ -> {Int|_v >= 0|0}
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, x4, xs arg0 == (Cons x xs) |- {Int|_v == 1 + x4|0} /\ {Int|_v >= 0|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, x1, xs arg0 == (Cons x xs) |- {Int|_v == 1 + x1|0} <: {Int|_v >= 0|0}
Constraints
  False ==> _v >= 0
QMap
  U0 -> {}
Checking consistency
  (((_v == 1 + x4 && arg0 == (Cons x xs)) && _v >= 0) && len arg0 >= 0) && len xs >= 0
Candidates (1)
  0: [U0 -> {}] (4 0)
Remaining Candidates (1)
  0: [U0 -> {}] (4 0)
INSTANTIATE <a> . arg0:{List {1**a||0}||0} -> {Int|_v >= 0|0}
INTO x6:{List {1**A2||0}||0} -> {Int|_v >= 0|0}

 
 Checking len :: x5:_ -> {Int||fp6} in
\arg0 . 
  match arg0 with
    Cons x xs -> 1 + (?? ??)
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : p29,x : p31,xs : p32 fp15
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- x6:{List {1**A2||0}||0} -> {Int|_v >= 0|0} /\ x5:_ -> {Int||fp6}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- x6:{List {1**A2||0}||0} -> {Int|_v >= 0|0} <: x5:_ -> {Int||fp6}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- x6:{List {1**A2||0}||0} -> {Int|False|0} <: arg0:{List {1**a|False|0}|False|0} -> {Int||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs |- {1**A2||0}
    Shared scalars: Emptyset Nil arg0 x xs fp13 \/
    Emptyset Nil arg0 x xs fp15 || Emptyset Nil arg0 x xs fp16
    Shared scalars: fp8 \/
    fp13 || fp14
UNIFY A2 WITH {1**a|False|0} PRODUCING {1**a|U1|0}
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
Typing Constraints
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, x5, xs arg0 == (Cons x xs) |- {Int|False|0} <: {Int||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- {1**a|False|0} <: {1**a|U1|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- {List|False|0} <: {List||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- {Int|False|0} <: {Int||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs |- {1**a|U1|0}
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- fp13 \/ fp15 || fp16
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len, x, xs arg0 == (Cons x xs) |- p14 \/ p29 || p34
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len, x, xs arg0 == (Cons x xs) |- p15 \/ p30 || p35
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- m5 \/ m14 || m17
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len, x, xs arg0 == (Cons x xs) |- p16 \/ p31 || p36
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- m6 \/ m15 || m18
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len, x, xs arg0 == (Cons x xs) |- p17 \/ p32 || p37
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len, x, xs arg0 == (Cons x xs) |- p18 \/ p33 || p38
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- m7 \/ m16 || m19
    Shared potential: |- fp8 \/ fp13 || fp14
Constraints
  False ==> True
  False ==> True
  False ==> U1
  False ==> True
QMap
  U0 -> {}
  U1 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}, U1 -> {}] (5 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}] (5 0)

 
 Checking xs :: {List {1**A2||0}||fp14} in
\arg0 . 
  match arg0 with
    Cons x xs -> 1 + (len ??)
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : p34,x : p36,xs : 0 fp16
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- {List {m19**a||p38}|_v == xs|p37} <: {List {1**A2||0}||fp14}
stripping var: Var IntS "p37"
stripping var: Var IntS "fp14"
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len, x, xs arg0 == (Cons x xs) |- p37 >= fp14
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- {m19**a||p38} <: {1**a|U1|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- {List|False|p37} <: {List||0}
Constraints
  False ==> True
  (arg0 == (Cons x xs) && len arg0 >= 0) && len xs >= 0 ==> U1
QMap
  U0 -> {}
  U1 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}, U1 -> {}] (6 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}] (6 0)

 
 Checking len
            xs :: {Int||fp6} in
\arg0 . 
  match arg0 with
    Cons x xs -> 1 + ??
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : p14,x : p16,xs : p17 fp8
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- {Int|_v >= 0|0} <: {Int||fp6}
stripping int: IntLit 0
stripping var: Var IntS "fp6"
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, len, x, xs arg0 == (Cons x xs) |- 0 >= fp6
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- {Int|False|0} <: {Int||0}
Constraints
  False ==> True
QMap
  U0 -> {}
  U1 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}, U1 -> {}] (6 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}] (6 0)

 
 Checking 1 + (len
                 xs) :: {Int|_v >= 0|0} in
\arg0 . 
  match arg0 with
    Cons x xs -> ??
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : p6,x : p7,xs : p8 fp4
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, xs arg0 == (Cons x xs) |- LET x4:({Int|_v >= 0|0}) IN {Int|_v == 1 + x4|0} <: {Int|_v >= 0|0}
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, len, x, x4, xs arg0 == (Cons x xs) |- {Int|_v == 1 + x4|0} <: {Int|_v >= 0|0}
Constraints
  (((_v == 1 + x4 && arg0 == (Cons x xs)) && x4 >= 0) && len arg0 >= 0) && len xs >= 0 ==> _v >= 0
QMap
  U0 -> {}
  U1 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}, U1 -> {}] (7 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}] (7 0)
INSTANTIATE <a> . {List {1**a||0}|_v == (Nil)|0}
INTO {List {1**A0||0}|_v == (Nil)|0}
INSTANTIATE <a> . x:{1**a||0} -> xs:{List {1**a||0}||0} -> {List {1**a||0}|_v == (Cons x xs)|0}
INTO x:{1**A1||0} -> xs:{List {1**A1||0}||0} -> {List {1**A1||0}|_v == (Cons x xs)|0}

 
 Checking arg0 :: {List {1**A0||0}||0} in
\arg0 . 
  match ?? with
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : 0 fp2
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len |- {List {m0**a||p1}|_v == arg0|p4} <: {List {1**A0||0}||0}
    Emptyset Nil arg0 ~ Emptyset Nil arg0 fp2
    Shared scalars: Emptyset Nil arg0 0 \/
    Emptyset Nil arg0 fp0 || Emptyset Nil arg0 fp1
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len |- {1**A1||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len |- {1**A0||0}
UNIFY A0 WITH {m0**a||p1} PRODUCING {m0**a|U0|p1}
stripping var: Var IntS "p1"
stripping var: Var IntS "p1"
Type assignment
  A0 -> {m0**a|U0|p1}
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len |- {1**A1||0}
Type assignment
  A0 -> {m0**a|U0|p1}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len |- p1 >= p1
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len |- {m0**a||0} <: {m0**a|U0|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len |- {List|False|p4} <: {List||0}
    Emptyset Nil arg0 ~ Emptyset Nil arg0 fp2
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len |- 0 \/ fp0 || fp1
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len |- 0 \/ p0 || p2
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len |- 0 \/ p1 || p3
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len |- 1 \/ m0 || m1
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len |- {m0**a|U0|p1}
Constraints
  False ==> True
  True ==> U0
QMap
  U0 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}] (2 0)
Remaining Candidates (1)
  0: [U0 -> {}] (2 0)
Matching constructor type
{List {0**A0||0}|_v == (Nil)|0}
with scrutinee
{List {m0**a||p1}|_v == arg0|p4}
INSTANTIATE <a> . {DSet {1**a||0}|_v == (Emptyset)|0}
INTO {DSet {1**A2|False|0}|_v == (Emptyset)|0}

 
 Checking Emptyset :: {DSet {1**a||0}||0} in
\arg0 . 
  match arg0 with
    Nil -> ??
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : p5 fp3
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len arg0 == (Nil) |- {DSet {1**A2|False|0}|_v == (Emptyset)|0} <: {DSet {1**a||0}||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len |- {1**A2||0}
    Emptyset Nil arg0 ~ Emptyset Nil arg0 fp3
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len |- {1**A1||0}
UNIFY A2 WITH {1**a||0} PRODUCING {1**a|U1|0}
Type assignment
  A0 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len |- {1**A1||0}
Type assignment
  A0 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len arg0 == (Nil) |- {1**a|False|0} <: {1**a||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len arg0 == (Nil) |- {DSet|False|0} <: {DSet||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len |- {1**a|U1|0}
    Emptyset Nil arg0 ~ Emptyset Nil arg0 fp3
Constraints
  False ==> True
  False ==> True
QMap
  U0 -> {}
  U1 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}, U1 -> {}] (2 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}] (2 0)
Matching constructor type
{List {1**A1||0}|_v == (Cons x xs)|0}
with scrutinee
{List {m0**a||p1}|_v == arg0|p4}
INSTANTIATE <a> . x:{DSet {1**a||0}||0} -> y:{DSet {1**a||0}||0} -> {DSet {1**a||0}|_v == x + y|0}
INTO x3:{DSet {1**A3||0}||0} -> x4:{DSet {1**A3||0}||0} -> {DSet {1**A3||0}|_v == x3 + x4|0}

 
 Checking + :: x2:_ -> x1:_ -> {DSet {1**a||0}||0} in
\arg0 . 
  match arg0 with
    Cons x xs -> ?? ?? ??
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : p19,x : p21,xs : p22 fp11
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- x3:{DSet {1**A3||0}||0} -> x4:{DSet {1**A3||0}||0} -> {DSet {1**A3||0}|_v == x3 + x4|0} /\ x2:_ -> x1:_ -> {DSet {1**a||0}||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- x3:{DSet {1**A3||0}||0} -> x4:{DSet {1**A3||0}||0} -> {DSet {1**A3||0}|_v == x3 + x4|0} <: x2:_ -> x1:_ -> {DSet {1**a||0}||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs |- {1**A3||0}
    Shared scalars: Emptyset Nil arg0 x xs fp9 \/
    Emptyset Nil arg0 x xs fp11 || Emptyset Nil arg0 x xs fp12
    Shared scalars: fp7 \/
    fp9 || fp10
    Shared scalars: Emptyset Nil arg0 x xs fp5 \/
    Emptyset Nil arg0 x xs fp7 || Emptyset Nil arg0 x xs fp8
    Shared scalars: fp4 \/
    fp5 || fp6
    Emptyset Nil arg0 x xs ~ Emptyset Nil arg0 x xs fp4
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len |- {1**A1||0}
UNIFY A3 WITH {1**a||0} PRODUCING {1**a|U2|0}
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
  A3 -> {1**a|U2|0}
Typing Constraints
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
  A3 -> {1**a|U2|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, x1, x2, xs arg0 == (Cons x xs) |- {1**a|False|0} <: {1**a||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, x1, x2, xs arg0 == (Cons x xs) |- {DSet|False|0} <: {DSet||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs |- {1**a|U2|0}
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- fp9 \/ fp11 || fp12
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p9 \/ p19 || p24
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p10 \/ p20 || p25
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- m2 \/ m8 || m11
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p11 \/ p21 || p26
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- m3 \/ m9 || m12
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p12 \/ p22 || p27
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p13 \/ p23 || p28
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- m4 \/ m10 || m13
    Shared potential: |- fp7 \/ fp9 || fp10
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- fp5 \/ fp7 || fp8
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p6 \/ p9 || p14
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p3 \/ p10 || p15
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- m1 \/ m2 || m5
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p7 \/ p11 || p16
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- m0 \/ m3 || m6
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p8 \/ p12 || p17
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p1 \/ p13 || p18
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- m0 \/ m4 || m7
    Shared potential: |- fp4 \/ fp5 || fp6
    Emptyset Nil arg0 x xs ~ Emptyset Nil arg0 x xs fp4
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len |- {m0**a||p1}
Constraints
  False ==> True
  False ==> True
QMap
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}] (2 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}] (2 0)
INSTANTIATE <a> . x:{1**a||0} -> {DSet {1**a||0}|_v == (Singleton x)|0}
INTO x6:{1**A4||0} -> {DSet {1**A4||0}|_v == (Singleton x6)|0}

 
 Checking Singleton :: x5:_ -> {DSet {1**A3||0}||fp10} in
\arg0 . 
  match arg0 with
    Cons x xs -> (?? ??) + ??
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : p29,x : p31,xs : p32 fp15
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- x6:{1**A4||0} -> {DSet {1**A4||0}|_v == (Singleton x6)|0} /\ x5:_ -> {DSet {1**A3||0}||fp10}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- x6:{1**A4||0} -> {DSet {1**A4||0}|_v == (Singleton x6)|0} <: x5:_ -> {DSet {1**A3||0}||fp10}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs |- {1**A4||0}
    Shared scalars: Emptyset Nil arg0 x xs fp13 \/
    Emptyset Nil arg0 x xs fp15 || Emptyset Nil arg0 x xs fp16
    Shared scalars: fp12 \/
    fp13 || fp14
UNIFY A4 WITH {1**a|U2|0} PRODUCING {1**a|U3|0}
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
  A3 -> {1**a|U2|0}
  A4 -> {1**a|U3|0}
Typing Constraints
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
  A3 -> {1**a|U2|0}
  A4 -> {1**a|U3|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, x6, xs arg0 == (Cons x xs) |- {1**a|U3|0} /\ {1**a|U2|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, x5, xs arg0 == (Cons x xs) |- {1**a|U3|0} <: {1**a|U2|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, x5, xs arg0 == (Cons x xs) |- {DSet|False|0} <: {DSet||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs |- {1**a|U3|0}
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- fp13 \/ fp15 || fp16
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p24 \/ p29 || p34
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p25 \/ p30 || p35
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- m11 \/ m14 || m17
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p26 \/ p31 || p36
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- m12 \/ m15 || m18
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p27 \/ p32 || p37
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p28 \/ p33 || p38
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- m13 \/ m16 || m19
    Shared potential: |- fp12 \/ fp13 || fp14
Constraints
  False ==> True
  ((U3 && arg0 == (Cons x xs)) && len arg0 >= 0) && len xs >= 0 ==> U2
QMap
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
  (((U2 && U3) && arg0 == (Cons x xs)) && len arg0 >= 0) && len xs >= 0
Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (3 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (3 0)

 
 Checking x :: {1**A4||fp14} in
\arg0 . 
  match arg0 with
    Cons x xs -> (Singleton ??) + ??
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : p34,x : 0,xs : p37 fp16
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- {m18**a|_v == x|p36} <: {1**A4||fp14}
stripping var: Var IntS "p36"
stripping var: Var IntS "fp14"
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
  A3 -> {1**a|U2|0}
  A4 -> {1**a|U3|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p36 >= fp14
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- {m18**a|_v == x|0} <: {1**a|U3|0}
Constraints
  ((_v == x && arg0 == (Cons x xs)) && len arg0 >= 0) && len xs >= 0 ==> U3
QMap
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (4 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (4 0)

 
 Checking Singleton
            x :: {DSet {1**A3||0}||fp10} in
\arg0 . 
  match arg0 with
    Cons x xs -> ?? + ??
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : p24,x : p26,xs : p27 fp12
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- {DSet {1**A4||0}|_v == (Singleton x)|0} <: {DSet {1**A3||0}||fp10}
stripping int: IntLit 0
stripping var: Var IntS "fp10"
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
  A3 -> {1**a|U2|0}
  A4 -> {1**a|U3|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- 0 >= fp10
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- {1**a|U3|0} <: {1**a|U2|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- {DSet|False|0} <: {DSet||0}
Constraints
  False ==> True
  ((U3 && arg0 == (Cons x xs)) && len arg0 >= 0) && len xs >= 0 ==> U2
QMap
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (4 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (4 0)

 
 Checking + (Singleton
               x) :: x1:_ -> {DSet {1**a||0}||0} in
\arg0 . 
  match arg0 with
    Cons x xs -> ?? ??
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : p9,x : p11,xs : p12 fp7
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- x4:LET x3:({DSet {0**A4||0}|_v == (Singleton x)|0}) IN {DSet {1**A3||0}||0} -> LET x3:({DSet {0**A4||0}|_v == (Singleton x)|0}) IN {DSet {1**A3||0}|_v == x3 + x4|0} /\ x1:_ -> {DSet {1**a||0}||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- x4:LET x3:({DSet {0**A4||0}|_v == (Singleton x)|0}) IN {DSet {1**A3||0}||0} -> LET x3:({DSet {0**A4||0}|_v == (Singleton x)|0}) IN {DSet {1**A3||0}|_v == x3 + x4|0} <: x1:_ -> {DSet {1**a||0}||0}
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
  A3 -> {1**a|U2|0}
  A4 -> {1**a|U3|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, x1, x3, xs arg0 == (Cons x xs) |- {1**a|False|0} <: {1**a||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, x1, x3, xs arg0 == (Cons x xs) |- {DSet|False|0} <: {DSet||0}
Constraints
  False ==> True
  False ==> True
QMap
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (4 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}] (4 0)
INSTANTIATE <a> . arg0:{List {1**a||0}||0} -> {DSet {1**a||0}||0}
INTO x8:{List {1**A5||0}||0} -> {DSet {1**A5||0}||0}

 
 Checking elems :: x7:_ -> LET x3:({DSet {0**A4||0}|_v == (Singleton x)|0}) IN {DSet {1**A3||0}||fp6} in
\arg0 . 
  match arg0 with
    Cons x xs -> (Singleton x) + (??
                                    ??)
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : p39,x : p41,xs : p42 fp19
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- x8:{List {1**A5||0}||0} -> {DSet {1**A5||0}||0} /\ x7:_ -> LET x3:({DSet {0**A4||0}|_v == (Singleton x)|0}) IN {DSet {1**A3||0}||fp6}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- x8:{List {1**A5||0}||0} -> {DSet {1**A5||0}||0} <: x7:_ -> LET x3:({DSet {0**A4||0}|_v == (Singleton x)|0}) IN {DSet {1**A3||0}||fp6}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- x8:{List {1**A5||0}||0} -> {DSet {1**A5|False|0}|False|0} <: arg0:{List {1**a|False|0}|False|0} -> {DSet {1**a||0}||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs |- {1**A5||0}
    Shared scalars: Emptyset Nil arg0 x xs fp17 \/
    Emptyset Nil arg0 x xs fp19 || Emptyset Nil arg0 x xs fp20
    Shared scalars: fp8 \/
    fp17 || fp18
UNIFY A5 WITH {1**a|U2|0} PRODUCING {1**a|U4|0}
stripping int: IntLit 0
stripping var: Var IntS "fp6"
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
  A3 -> {1**a|U2|0}
  A4 -> {1**a|U3|0}
  A5 -> {1**a|U4|0}
Typing Constraints
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
  A3 -> {1**a|U2|0}
  A4 -> {1**a|U3|0}
  A5 -> {1**a|U4|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, x3, x8, xs arg0 == (Cons x xs) |- {1**a|U4|0} /\ {1**a|U2|0}
    Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, x3, x7, xs arg0 == (Cons x xs) |- 0 >= fp6
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, x3, x7, xs arg0 == (Cons x xs) |- {1**a|U4|0} <: {1**a|U2|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, x3, x7, xs arg0 == (Cons x xs) |- {DSet|False|0} <: {DSet||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- {1**a|False|0} <: {1**a|U4|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- {List|False|0} <: {List||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- {1**a|False|0} <: {1**a||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- {DSet|False|0} <: {DSet||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs |- {1**a|U4|0}
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- fp17 \/ fp19 || fp20
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p14 \/ p39 || p44
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p15 \/ p40 || p45
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- m5 \/ m20 || m23
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p16 \/ p41 || p46
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- m6 \/ m21 || m24
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p17 \/ p42 || p47
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p18 \/ p43 || p48
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- m7 \/ m22 || m25
    Shared potential: |- fp8 \/ fp17 || fp18
Constraints
  False ==> True
  False ==> True
  False ==> True
  False ==> U4
  False ==> True
  ((U4 && arg0 == (Cons x xs)) && len arg0 >= 0) && len xs >= 0 ==> U2
QMap
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
  (((U2 && U4) && arg0 == (Cons x xs)) && len arg0 >= 0) && len xs >= 0
Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (6 0)

 
 Checking xs :: {List {1**A5||0}||fp18} in
\arg0 . 
  match arg0 with
    Cons x xs -> (Singleton x) +
                   (elems ??)
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : p44,x : p46,xs : 0 fp20
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- {List {m25**a||p48}|_v == xs|p47} <: {List {1**A5||0}||fp18}
stripping var: Var IntS "p47"
stripping var: Var IntS "fp18"
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
  A3 -> {1**a|U2|0}
  A4 -> {1**a|U3|0}
  A5 -> {1**a|U4|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- p47 >= fp18
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- {m25**a||p48} <: {1**a|U4|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- {List|False|p47} <: {List||0}
Constraints
  False ==> True
  (arg0 == (Cons x xs) && len arg0 >= 0) && len xs >= 0 ==> U4
QMap
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)

 
 Checking elems
            xs :: LET x3:({DSet {0**A4||0}|_v == (Singleton x)|0}) IN {DSet {1**A3||0}||fp6} in
\arg0 . 
  match arg0 with
    Cons x xs -> (Singleton x) + ??
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : p14,x : p16,xs : p17 fp8
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- {DSet {1**A5||0}||0} <: LET x3:({DSet {0**A4||0}|_v == (Singleton x)|0}) IN {DSet {1**A3||0}||fp6}
stripping int: IntLit 0
stripping var: Var IntS "fp6"
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
  A3 -> {1**a|U2|0}
  A4 -> {1**a|U3|0}
  A5 -> {1**a|U4|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, _v, append, arg0, elems, len, x, x3, xs arg0 == (Cons x xs) |- 0 >= fp6
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, x3, xs arg0 == (Cons x xs) |- {1**a|U4|0} <: {1**a|U2|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, x3, xs arg0 == (Cons x xs) |- {DSet|False|0} <: {DSet||0}
Constraints
  False ==> True
  ((U4 && arg0 == (Cons x xs)) && len arg0 >= 0) && len xs >= 0 ==> U2
QMap
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)

 
 Checking (Singleton x) + (elems
                             xs) :: {DSet {1**a||0}||0} in
\arg0 . 
  match arg0 with
    Cons x xs -> ??
from env with top-level potentials: Emptyset : 0,Nil : 0,arg0 : p6,x : p7,xs : p8 fp4
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, xs arg0 == (Cons x xs) |- LET x4:({DSet {0**A5||0}||0}) IN LET x3:({DSet {0**A4||0}|_v == (Singleton x)|0}) IN {DSet {1**A3||0}|_v == x3 + x4|0} <: {DSet {1**a||0}||0}
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
  A3 -> {1**a|U2|0}
  A4 -> {1**a|U3|0}
  A5 -> {1**a|U4|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, x3, x4, xs arg0 == (Cons x xs) |- {1**a|False|0} <: {1**a||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, arg0, elems, len, x, x3, x4, xs arg0 == (Cons x xs) |- {DSet|False|0} <: {DSet||0}
Constraints
  False ==> True
  False ==> True
QMap
  U0 -> {}
  U1 -> {}
  U2 -> {}
  U3 -> {}
  U4 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}, U3 -> {}, U4 -> {}] (7 0)
INSTANTIATE <a> . {List {1**a||0}|_v == (Nil)|0}
INTO {List {1**A0||0}|_v == (Nil)|0}
INSTANTIATE <a> . x:{1**a||0} -> xs:{List {1**a||0}||0} -> {List {1**a||0}|_v == (Cons x xs)|0}
INTO z:{1**A1||0} -> zs:{List {1**A1||0}||0} -> {List {1**A1||0}|_v == (Cons z zs)|0}

 
 Checking xs :: {List {1**A0||0}||0} in
\xs . \ys . 
    match ?? with
from env with top-level potentials: Emptyset : 0,Nil : 0,xs : 0,ys : p9 fp2
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys |- {List {m0**a||p1}|_v == xs|p8} <: {List {1**A0||0}||0}
    Emptyset Nil xs ys ~ Emptyset Nil xs ys fp2
    Shared scalars: Emptyset Nil xs ys 0 \/
    Emptyset Nil xs ys fp0 || Emptyset Nil xs ys fp1
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys |- {1**A1||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys |- {1**A0||0}
UNIFY A0 WITH {m0**a||p1} PRODUCING {m0**a|U0|p1}
stripping var: Var IntS "p1"
stripping var: Var IntS "p1"
Type assignment
  A0 -> {m0**a|U0|p1}
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys |- {1**A1||0}
Type assignment
  A0 -> {m0**a|U0|p1}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys |- p1 >= p1
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys |- {m0**a||0} <: {m0**a|U0|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys |- {List|False|p8} <: {List||0}
    Emptyset Nil xs ys ~ Emptyset Nil xs ys fp2
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys |- 0 \/ fp0 || fp1
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys |- 0 \/ p0 || p4
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys |- 1 \/ p1 || p5
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys |- 1 \/ m0 || m2
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys |- 0 \/ p2 || p6
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys |- 0 \/ p3 || p7
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys |- 1 \/ m1 || m3
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys |- {m0**a|U0|p1}
Constraints
  False ==> True
  True ==> U0
QMap
  U0 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}] (2 0)
Remaining Candidates (1)
  0: [U0 -> {}] (2 0)

Generating resource constraints:
  p1 >= p1 ~>
      p1 >= p1
  Emptyset Nil xs ys ~ Emptyset Nil xs ys ~>
      ((((p0 + p2) + fp0 == (p8 + p9) + fp2 && fp0 >= 0) && fp2 >= 0) && p8 >= 0) && p9 >= 0
  0 \/ fp0 || fp1 ~>
      ((0 >= 0 && fp0 >= 0) && fp1 >= 0) && 0 == fp0 + fp1
  0 \/ p0 || p4 ~>
      ((0 >= 0 && p0 >= 0) && p4 >= 0) && 0 == p0 + p4
  1 \/ p1 || p5 ~>
      ((1 >= 0 && p1 >= 0) && p5 >= 0) && 1 == p1 + p5
  1 \/ m0 || m2 ~>
      ((1 >= 0 && m0 >= 0) && m2 >= 0) && 1 == m0 + m2
  0 \/ p2 || p6 ~>
      ((0 >= 0 && p2 >= 0) && p6 >= 0) && 0 == p2 + p6
  0 \/ p3 || p7 ~>
      ((0 >= 0 && p3 >= 0) && p7 >= 0) && 0 == p3 + p7
  1 \/ m1 || m3 ~>
      ((1 >= 0 && m1 >= 0) && m3 >= 0) && 1 == m1 + m3
  Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys |- {m0**a|U0|p1} ~>
      p1 >= 0
Solved resource constraint after conjoining formulas: SAT
    p1 >= p1
    (p0 + p2) + fp0 == (p8 + p9) + fp2
    (0 >= 0) && 0 == fp0 + fp1
    (0 >= 0) && 0 == p0 + p4
    (1 >= 0) && 1 == p1 + p5
    (1 >= 0) && 1 == m0 + m2
    (0 >= 0) && 0 == p2 + p6
    (0 >= 0) && 0 == p3 + p7
    (1 >= 0) && 1 == m1 + m3
    p1 >= 0
Matching constructor type
{List {0**A0||0}|_v == (Nil)|0}
with scrutinee
{List {m0**a||p1}|_v == xs|p8}

 
 Checking ys :: {List {1**a||0}|len _v == len xs + len ys && elems _v == elems xs + elems ys|0} in
\xs . \ys . 
    match xs with
      Nil -> ??
from env with top-level potentials: Emptyset : 0,Nil : 0,xs : p10,ys : 0 fp3
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys xs == (Nil) |- {List {m3**a||p7}|_v == ys|p11} <: {List {1**a||0}|len _v == len xs + len ys && elems _v == elems xs + elems ys|0}
    Emptyset Nil xs ys ~ Emptyset Nil xs ys fp3
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys |- {1**A1||0}
Type assignment
  A0 -> {m0**a||p1}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys xs == (Nil) |- {m3**a|False|p7} <: {1**a||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys xs == (Nil) |- {List|_v == ys|p11} <: {List|len _v == len xs + len ys && elems _v == elems xs + elems ys|0}
    Emptyset Nil xs ys ~ Emptyset Nil xs ys fp3
Constraints
  ((_v == ys && xs == (Nil)) && len xs >= 0) && len ys >= 0 ==> len _v == len xs + len ys && elems _v == elems xs + elems ys
  False ==> True
QMap
  U0 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}] (3 0)
Remaining Candidates (1)
  0: [U0 -> {}] (3 0)

Generating resource constraints:
  Emptyset Nil xs ys ~ Emptyset Nil xs ys ~>
      ((((p4 + p6) + fp1 == (p10 + p11) + fp3 && fp1 >= 0) && fp3 >= 0) && p10 >= 0) && p11 >= 0
Solved resource constraint after conjoining formulas: SAT
    (p4 + p6) + fp1 == (p10 + p11) + fp3
Matching constructor type
{List {1**A1||0}|_v == (Cons z zs)|0}
with scrutinee
{List {m0**a||p1}|_v == xs|p8}
INSTANTIATE <a> . x:{1**a||0} -> xs:{List {1**a||0}||0} -> {List {1**a||0}|_v == (Cons x xs)|0}
INTO x4:{1**A2||0} -> x5:{List {1**A2||0}||0} -> {List {1**A2||0}|_v == (Cons x4 x5)|0}

 
 Checking Cons :: x3:_ -> x2:_ -> {List {1**a||0}|len _v == len xs + len ys && elems _v == elems xs + elems ys|0} in
\xs . \ys . 
    match xs with
      Cons z zs -> ?? ?? ??
from env with top-level potentials: Emptyset : 0,Nil : 0,xs : p30,ys : p32,z : p34,zs : p35 fp11
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- x4:{1**A2||0} -> x5:{List {1**A2||0}||0} -> {List {1**A2||0}|_v == (Cons x4 x5)|0} /\ x3:_ -> x2:_ -> {List {1**a||0}|len _v == len xs + len ys && elems _v == elems xs + elems ys|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- x4:{1**A2||0} -> x5:{List {1**A2||0}||0} -> {List {1**A2||0}|_v == (Cons x4 x5)|0} <: x3:_ -> x2:_ -> {List {1**a||0}|len _v == len xs + len ys && elems _v == elems xs + elems ys|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs |- {1**A2||0}
    Shared scalars: Emptyset Nil xs ys z zs fp9 \/
    Emptyset Nil xs ys z zs fp11 || Emptyset Nil xs ys z zs fp12
    Shared scalars: fp7 \/
    fp9 || fp10
    Shared scalars: Emptyset Nil xs ys z zs fp5 \/
    Emptyset Nil xs ys z zs fp7 || Emptyset Nil xs ys z zs fp8
    Shared scalars: fp4 \/
    fp5 || fp6
    Emptyset Nil xs ys z zs ~ Emptyset Nil xs ys z zs fp4
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys |- {1**A1||0}
UNIFY A2 WITH {1**a||0} PRODUCING {1**a|U1|0}
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
Typing Constraints
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, x4, x5, xs, ys, z, zs xs == (Cons z zs) |- {List|_v == (Cons x4 x5)|0} /\ {List|len _v == len xs + len ys && elems _v == elems xs + elems ys|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, x2, x3, xs, ys, z, zs xs == (Cons z zs) |- {1**a|False|0} <: {1**a||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, x2, x3, xs, ys, z, zs xs == (Cons z zs) |- {List|elems _v == [x3] + elems x2|0} <: {List|elems _v == elems xs + elems ys|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, x2, x3, xs, ys, z, zs xs == (Cons z zs) |- {List|len _v == 1 + len x2|0} <: {List|len _v == len xs + len ys|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs |- {1**a|U1|0}
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- fp9 \/ fp11 || fp12
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p16 \/ p30 || p37
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p17 \/ p31 || p38
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- m4 \/ m12 || m16
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p18 \/ p32 || p39
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p19 \/ p33 || p40
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- m5 \/ m13 || m17
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p20 \/ p34 || p41
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- m6 \/ m14 || m18
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p21 \/ p35 || p42
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p22 \/ p36 || p43
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- m7 \/ m15 || m19
    Shared potential: |- fp7 \/ fp9 || fp10
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- fp5 \/ fp7 || fp8
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p12 \/ p16 || p23
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p5 \/ p17 || p24
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- m2 \/ m4 || m8
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p13 \/ p18 || p25
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p7 \/ p19 || p26
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- m3 \/ m5 || m9
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p14 \/ p20 || p27
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- m0 \/ m6 || m10
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p15 \/ p21 || p28
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p1 \/ p22 || p29
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- m0 \/ m7 || m11
    Shared potential: |- fp4 \/ fp5 || fp6
    Emptyset Nil xs ys z zs ~ Emptyset Nil xs ys z zs fp4
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys |- {m0**a||p1}
Constraints
  False ==> len _v == len xs + len ys
  False ==> elems _v == elems xs + elems ys
  False ==> True
QMap
  U0 -> {}
  U1 -> {}
Checking consistency
  (((((([_v -> x4]U1 && _v == (Cons x4 x5)) && xs == (Cons z zs)) && len x5 >= 0) && len xs >= 0) && len ys >= 0) && len zs >= 0) && (len _v == len xs + len ys && elems _v == elems xs + elems ys)
Candidates (1)
  0: [U0 -> {}, U1 -> {}] (5 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}] (5 0)

Generating resource constraints:
  Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs |- {1**a|U1|0} ~>
      0 >= 0
  fp9 \/ fp11 || fp12 ~>
      ((fp9 >= 0 && fp11 >= 0) && fp12 >= 0) && fp9 == fp11 + fp12
  p16 \/ p30 || p37 ~>
      ((p16 >= 0 && p30 >= 0) && p37 >= 0) && p16 == p30 + p37
  p17 \/ p31 || p38 ~>
      ((p17 >= 0 && p31 >= 0) && p38 >= 0) && p17 == p31 + p38
  m4 \/ m12 || m16 ~>
      ((m4 >= 0 && m12 >= 0) && m16 >= 0) && m4 == m12 + m16
  p18 \/ p32 || p39 ~>
      ((p18 >= 0 && p32 >= 0) && p39 >= 0) && p18 == p32 + p39
  p19 \/ p33 || p40 ~>
      ((p19 >= 0 && p33 >= 0) && p40 >= 0) && p19 == p33 + p40
  m5 \/ m13 || m17 ~>
      ((m5 >= 0 && m13 >= 0) && m17 >= 0) && m5 == m13 + m17
  p20 \/ p34 || p41 ~>
      ((p20 >= 0 && p34 >= 0) && p41 >= 0) && p20 == p34 + p41
  m6 \/ m14 || m18 ~>
      ((m6 >= 0 && m14 >= 0) && m18 >= 0) && m6 == m14 + m18
  p21 \/ p35 || p42 ~>
      ((p21 >= 0 && p35 >= 0) && p42 >= 0) && p21 == p35 + p42
  p22 \/ p36 || p43 ~>
      ((p22 >= 0 && p36 >= 0) && p43 >= 0) && p22 == p36 + p43
  m7 \/ m15 || m19 ~>
      ((m7 >= 0 && m15 >= 0) && m19 >= 0) && m7 == m15 + m19
  fp7 \/ fp9 || fp10 ~>
      ((fp7 >= 0 && fp9 >= 0) && fp10 >= 0) && fp7 == fp9 + fp10
  fp5 \/ fp7 || fp8 ~>
      ((fp5 >= 0 && fp7 >= 0) && fp8 >= 0) && fp5 == fp7 + fp8
  p12 \/ p16 || p23 ~>
      ((p12 >= 0 && p16 >= 0) && p23 >= 0) && p12 == p16 + p23
  p5 \/ p17 || p24 ~>
      ((p5 >= 0 && p17 >= 0) && p24 >= 0) && p5 == p17 + p24
  m2 \/ m4 || m8 ~>
      ((m2 >= 0 && m4 >= 0) && m8 >= 0) && m2 == m4 + m8
  p13 \/ p18 || p25 ~>
      ((p13 >= 0 && p18 >= 0) && p25 >= 0) && p13 == p18 + p25
  p7 \/ p19 || p26 ~>
      ((p7 >= 0 && p19 >= 0) && p26 >= 0) && p7 == p19 + p26
  m3 \/ m5 || m9 ~>
      ((m3 >= 0 && m5 >= 0) && m9 >= 0) && m3 == m5 + m9
  p14 \/ p20 || p27 ~>
      ((p14 >= 0 && p20 >= 0) && p27 >= 0) && p14 == p20 + p27
  m0 \/ m6 || m10 ~>
      ((m0 >= 0 && m6 >= 0) && m10 >= 0) && m0 == m6 + m10
  p15 \/ p21 || p28 ~>
      ((p15 >= 0 && p21 >= 0) && p28 >= 0) && p15 == p21 + p28
  p1 \/ p22 || p29 ~>
      ((p1 >= 0 && p22 >= 0) && p29 >= 0) && p1 == p22 + p29
  m0 \/ m7 || m11 ~>
      ((m0 >= 0 && m7 >= 0) && m11 >= 0) && m0 == m7 + m11
  fp4 \/ fp5 || fp6 ~>
      ((fp4 >= 0 && fp5 >= 0) && fp6 >= 0) && fp4 == fp5 + fp6
  Emptyset Nil xs ys z zs ~ Emptyset Nil xs ys z zs ~>
      (((((((p4 + p6) + p1) + fp1 == (((p12 + p13) + p14) + p15) + fp4 && fp1 >= 0) && fp4 >= 0) && p12 >= 0) && p13 >= 0) && p14 >= 0) && p15 >= 0
  Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys |- {m0**a||p1} ~>
      p1 >= 0
Solved resource constraint after conjoining formulas: SAT
    0 >= 0
    (fp9 >= 0) && fp9 == fp11 + fp12
    (p16 >= 0) && p16 == p30 + p37
    (p17 >= 0) && p17 == p31 + p38
    (m4 >= 0) && m4 == m12 + m16
    (p18 >= 0) && p18 == p32 + p39
    (p19 >= 0) && p19 == p33 + p40
    (m5 >= 0) && m5 == m13 + m17
    (p20 >= 0) && p20 == p34 + p41
    (m6 >= 0) && m6 == m14 + m18
    (p21 >= 0) && p21 == p35 + p42
    (p22 >= 0) && p22 == p36 + p43
    (m7 >= 0) && m7 == m15 + m19
    (fp7 >= 0) && fp7 == fp9 + fp10
    (fp5 >= 0) && fp5 == fp7 + fp8
    (p12 >= 0) && p12 == p16 + p23
    (p5 >= 0) && p5 == p17 + p24
    (m2 >= 0) && m2 == m4 + m8
    (p13 >= 0) && p13 == p18 + p25
    (p7 >= 0) && p7 == p19 + p26
    (m3 >= 0) && m3 == m5 + m9
    (p14 >= 0) && p14 == p20 + p27
    (m0 >= 0) && m0 == m6 + m10
    (p15 >= 0) && p15 == p21 + p28
    (p1 >= 0) && p1 == p22 + p29
    (m0 >= 0) && m0 == m7 + m11
    (fp4 >= 0) && fp4 == fp5 + fp6
    ((p4 + p6) + p1) + fp1 == (((p12 + p13) + p14) + p15) + fp4
    p1 >= 0

 
 Checking z :: {1**A2||fp10} in
\xs . \ys . 
    match xs with
      Cons z zs -> Cons ?? ??
from env with top-level potentials: Emptyset : 0,Nil : 0,xs : p37,ys : p39,z : 0,zs : p42 fp12
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- {m18**a|_v == z|p41} <: {1**A2||fp10}
stripping var: Var IntS "p41"
stripping var: Var IntS "fp10"
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p41 >= fp10
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- {m18**a|_v == z|0} <: {1**a|U1|0}
Constraints
  ((_v == z && xs == (Cons z zs)) && len xs >= 0) && len zs >= 0 ==> U1
QMap
  U0 -> {}
  U1 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}, U1 -> {}] (6 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}] (6 0)

Generating resource constraints:
  p41 >= fp10 ~>
      p41 >= fp10
Solved resource constraint after conjoining formulas: SAT
    p41 >= fp10

 
 Checking Cons
            z :: x2:_ -> {List {1**a||0}|len _v == len xs + len ys && elems _v == elems xs + elems ys|0} in
\xs . \ys . 
    match xs with
      Cons z zs -> ?? ??
from env with top-level potentials: Emptyset : 0,Nil : 0,xs : p16,ys : p18,z : p20,zs : p21 fp7
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- x5:{List {1**A2||0}||0} -> {List {1**A2||0}|_v == (Cons z x5)|0} /\ x2:_ -> {List {1**a||0}|len _v == len xs + len ys && elems _v == elems xs + elems ys|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- x5:{List {1**A2||0}||0} -> {List {1**A2||0}|_v == (Cons z x5)|0} <: x2:_ -> {List {1**a||0}|len _v == len xs + len ys && elems _v == elems xs + elems ys|0}
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, x5, xs, ys, z, zs xs == (Cons z zs) |- {List|_v == (Cons z x5)|0} /\ {List|len _v == len xs + len ys && elems _v == elems xs + elems ys|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, x2, xs, ys, z, zs xs == (Cons z zs) |- {1**a|False|0} <: {1**a||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, x2, xs, ys, z, zs xs == (Cons z zs) |- {List|elems _v == [z] + elems x2|0} <: {List|elems _v == elems xs + elems ys|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, x2, xs, ys, z, zs xs == (Cons z zs) |- {List|len _v == 1 + len x2|0} <: {List|len _v == len xs + len ys|0}
Constraints
  False ==> len _v == len xs + len ys
  False ==> elems _v == elems xs + elems ys
  False ==> True
QMap
  U0 -> {}
  U1 -> {}
Checking consistency
  (((((_v == (Cons z x5) && xs == (Cons z zs)) && len x5 >= 0) && len xs >= 0) && len ys >= 0) && len zs >= 0) && (len _v == len xs + len ys && elems _v == elems xs + elems ys)
Candidates (1)
  0: [U0 -> {}, U1 -> {}] (6 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}] (6 0)
INSTANTIATE <a> . x0:{List {1**a||1}|len _v >= 0 && len _v < len xs|0} -> ys:{List {1**a||0}||0} -> {List {1**a||0}|len _v == len x0 + len ys && elems _v == elems x0 + elems ys|0}
INTO x8:{List {1**A3||1}|len _v >= 0 && len _v < len xs|0} -> x9:{List {1**A3||0}||0} -> {List {1**A3||0}|len _v == len x8 + len x9 && elems _v == elems x8 + elems x9|0}

 
 Checking append :: x7:_ -> x6:_ -> {List {1**A2||0}||fp6} in
\xs . \ys . 
    match xs with
      Cons z zs -> Cons z (?? ?? ??)
from env with top-level potentials: Emptyset : 0,Nil : 0,xs : p58,ys : p60,z : p62,zs : p63 fp19
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- x8:{List {1**A3||1}|len _v >= 0 && len _v < len xs|0} -> x9:{List {1**A3||0}||0} -> {List {1**A3||0}|len _v == len x8 + len x9 && elems _v == elems x8 + elems x9|0} /\ x7:_ -> x6:_ -> {List {1**A2||0}||fp6}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- x8:{List {1**A3||1}|len _v >= 0 && len _v < len xs|0} -> x9:{List {1**A3||0}||0} -> {List {1**A3||0}|len _v == len x8 + len x9 && elems _v == elems x8 + elems x9|0} <: x7:_ -> x6:_ -> {List {1**A2||0}||fp6}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- x8:{List {1**A3||0}||0} -> x9:{List {1**A3||0}||0} -> {List {1**A3|False|0}|False|0} <: xs:{List {1**a|False|0}|False|0} -> ys:{List {1**a|False|0}|False|0} -> {List {1**a||0}||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs |- {1**A3||0}
    Shared scalars: Emptyset Nil xs ys z zs fp17 \/
    Emptyset Nil xs ys z zs fp19 || Emptyset Nil xs ys z zs fp20
    Shared scalars: fp15 \/
    fp17 || fp18
    Shared scalars: Emptyset Nil xs ys z zs fp13 \/
    Emptyset Nil xs ys z zs fp15 || Emptyset Nil xs ys z zs fp16
    Shared scalars: fp8 \/
    fp13 || fp14
UNIFY A3 WITH {1**a|U1|0} PRODUCING {1**a|U2|0}
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
  A3 -> {1**a|U2|0}
Typing Constraints
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
  A3 -> {1**a|U2|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, x8, x9, xs, ys, z, zs xs == (Cons z zs) |- {1**a|U2|0} /\ {1**a|U1|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, x6, x7, xs, ys, z, zs xs == (Cons z zs) |- {1**a|U2|0} <: {1**a|U1|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, x6, x7, xs, ys, z, zs xs == (Cons z zs) |- {List|False|0} <: {List||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- {1**a|False|0} <: {1**a|U2|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- {List|False|0} <: {List||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- {1**a|False|0} <: {1**a|U2|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- {List|False|0} <: {List||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- {1**a|False|0} <: {1**a||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- {List|False|0} <: {List||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs |- {1**a|U2|0}
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- fp17 \/ fp19 || fp20
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p44 \/ p58 || p65
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p45 \/ p59 || p66
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- m20 \/ m28 || m32
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p46 \/ p60 || p67
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p47 \/ p61 || p68
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- m21 \/ m29 || m33
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p48 \/ p62 || p69
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- m22 \/ m30 || m34
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p49 \/ p63 || p70
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p50 \/ p64 || p71
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- m23 \/ m31 || m35
    Shared potential: |- fp15 \/ fp17 || fp18
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- fp13 \/ fp15 || fp16
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p23 \/ p44 || p51
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p24 \/ p45 || p52
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- m8 \/ m20 || m24
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p25 \/ p46 || p53
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p26 \/ p47 || p54
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- m9 \/ m21 || m25
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p27 \/ p48 || p55
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- m10 \/ m22 || m26
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p28 \/ p49 || p56
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p29 \/ p50 || p57
    Shared potential: Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- m11 \/ m23 || m27
    Shared potential: |- fp8 \/ fp13 || fp14
Constraints
  False ==> True
  False ==> True
  False ==> True
  False ==> U2
  False ==> True
  False ==> U2
  False ==> True
  ((U2 && xs == (Cons z zs)) && len xs >= 0) && len zs >= 0 ==> U1
QMap
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  (((U1 && U2) && xs == (Cons z zs)) && len xs >= 0) && len zs >= 0
Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}] (8 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}] (8 0)

Generating resource constraints:
  Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs |- {1**a|U2|0} ~>
      0 >= 0
  fp17 \/ fp19 || fp20 ~>
      ((fp17 >= 0 && fp19 >= 0) && fp20 >= 0) && fp17 == fp19 + fp20
  p44 \/ p58 || p65 ~>
      ((p44 >= 0 && p58 >= 0) && p65 >= 0) && p44 == p58 + p65
  p45 \/ p59 || p66 ~>
      ((p45 >= 0 && p59 >= 0) && p66 >= 0) && p45 == p59 + p66
  m20 \/ m28 || m32 ~>
      ((m20 >= 0 && m28 >= 0) && m32 >= 0) && m20 == m28 + m32
  p46 \/ p60 || p67 ~>
      ((p46 >= 0 && p60 >= 0) && p67 >= 0) && p46 == p60 + p67
  p47 \/ p61 || p68 ~>
      ((p47 >= 0 && p61 >= 0) && p68 >= 0) && p47 == p61 + p68
  m21 \/ m29 || m33 ~>
      ((m21 >= 0 && m29 >= 0) && m33 >= 0) && m21 == m29 + m33
  p48 \/ p62 || p69 ~>
      ((p48 >= 0 && p62 >= 0) && p69 >= 0) && p48 == p62 + p69
  m22 \/ m30 || m34 ~>
      ((m22 >= 0 && m30 >= 0) && m34 >= 0) && m22 == m30 + m34
  p49 \/ p63 || p70 ~>
      ((p49 >= 0 && p63 >= 0) && p70 >= 0) && p49 == p63 + p70
  p50 \/ p64 || p71 ~>
      ((p50 >= 0 && p64 >= 0) && p71 >= 0) && p50 == p64 + p71
  m23 \/ m31 || m35 ~>
      ((m23 >= 0 && m31 >= 0) && m35 >= 0) && m23 == m31 + m35
  fp15 \/ fp17 || fp18 ~>
      ((fp15 >= 0 && fp17 >= 0) && fp18 >= 0) && fp15 == fp17 + fp18
  fp13 \/ fp15 || fp16 ~>
      ((fp13 >= 0 && fp15 >= 0) && fp16 >= 0) && fp13 == fp15 + fp16
  p23 \/ p44 || p51 ~>
      ((p23 >= 0 && p44 >= 0) && p51 >= 0) && p23 == p44 + p51
  p24 \/ p45 || p52 ~>
      ((p24 >= 0 && p45 >= 0) && p52 >= 0) && p24 == p45 + p52
  m8 \/ m20 || m24 ~>
      ((m8 >= 0 && m20 >= 0) && m24 >= 0) && m8 == m20 + m24
  p25 \/ p46 || p53 ~>
      ((p25 >= 0 && p46 >= 0) && p53 >= 0) && p25 == p46 + p53
  p26 \/ p47 || p54 ~>
      ((p26 >= 0 && p47 >= 0) && p54 >= 0) && p26 == p47 + p54
  m9 \/ m21 || m25 ~>
      ((m9 >= 0 && m21 >= 0) && m25 >= 0) && m9 == m21 + m25
  p27 \/ p48 || p55 ~>
      ((p27 >= 0 && p48 >= 0) && p55 >= 0) && p27 == p48 + p55
  m10 \/ m22 || m26 ~>
      ((m10 >= 0 && m22 >= 0) && m26 >= 0) && m10 == m22 + m26
  p28 \/ p49 || p56 ~>
      ((p28 >= 0 && p49 >= 0) && p56 >= 0) && p28 == p49 + p56
  p29 \/ p50 || p57 ~>
      ((p29 >= 0 && p50 >= 0) && p57 >= 0) && p29 == p50 + p57
  m11 \/ m23 || m27 ~>
      ((m11 >= 0 && m23 >= 0) && m27 >= 0) && m11 == m23 + m27
  fp8 \/ fp13 || fp14 ~>
      ((fp8 >= 0 && fp13 >= 0) && fp14 >= 0) && fp8 == fp13 + fp14
Solved resource constraint after conjoining formulas: SAT
    0 >= 0
    (fp17 >= 0) && fp17 == fp19 + fp20
    (p44 >= 0) && p44 == p58 + p65
    (p45 >= 0) && p45 == p59 + p66
    (m20 >= 0) && m20 == m28 + m32
    (p46 >= 0) && p46 == p60 + p67
    (p47 >= 0) && p47 == p61 + p68
    (m21 >= 0) && m21 == m29 + m33
    (p48 >= 0) && p48 == p62 + p69
    (m22 >= 0) && m22 == m30 + m34
    (p49 >= 0) && p49 == p63 + p70
    (p50 >= 0) && p50 == p64 + p71
    (m23 >= 0) && m23 == m31 + m35
    (fp15 >= 0) && fp15 == fp17 + fp18
    (fp13 >= 0) && fp13 == fp15 + fp16
    (p23 >= 0) && p23 == p44 + p51
    (p24 >= 0) && p24 == p45 + p52
    (m8 >= 0) && m8 == m20 + m24
    (p25 >= 0) && p25 == p46 + p53
    (p26 >= 0) && p26 == p47 + p54
    (m9 >= 0) && m9 == m21 + m25
    (p27 >= 0) && p27 == p48 + p55
    (m10 >= 0) && m10 == m22 + m26
    (p28 >= 0) && p28 == p49 + p56
    (p29 >= 0) && p29 == p50 + p57
    (m11 >= 0) && m11 == m23 + m27
    (fp8 >= 0) && fp8 == fp13 + fp14

 
 Checking zs :: {List {1**A3||1}|len _v >= 0 && len _v < len xs|fp18} in
\xs . \ys . 
    match xs with
      Cons z zs -> Cons z (append ??
                             ??)
from env with top-level potentials: Emptyset : 0,Nil : 0,xs : p65,ys : p67,z : p69,zs : 0 fp20
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- {List {m35**a||p71}|_v == zs|p70} <: {List {1**A3||1}|len _v >= 0 && len _v < len xs|fp18}
stripping var: Var IntS "p70"
stripping var: Var IntS "fp18"
stripping var: Var IntS "p71"
stripping int: IntLit 1
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
  A3 -> {1**a|U2|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p70 >= fp18
    Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p71 >= 1
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- {m35**a||0} <: {1**a|U2|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- {List|_v == zs|p70} <: {List|len _v >= 0 && len _v < len xs|0}
Constraints
  ((_v == zs && xs == (Cons z zs)) && len xs >= 0) && len zs >= 0 ==> len _v >= 0 && len _v < len xs
  (xs == (Cons z zs) && len xs >= 0) && len zs >= 0 ==> U2
QMap
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}] (10 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}] (10 0)

Generating resource constraints:
  p70 >= fp18 ~>
      p70 >= fp18
  p71 >= 1 ~>
      p71 >= 1
Solved resource constraint after conjoining formulas: SAT
    p70 >= fp18
    p71 >= 1

 
 Checking append
            zs :: x6:_ -> {List {1**A2||0}||fp6} in
\xs . \ys . 
    match xs with
      Cons z zs -> Cons z (?? ??)
from env with top-level potentials: Emptyset : 0,Nil : 0,xs : p44,ys : p46,z : p48,zs : p49 fp15
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- x9:{List {1**A3||0}||0} -> {List {1**A3||0}|len _v == len zs + len x9 && elems _v == elems zs + elems x9|0} /\ x6:_ -> {List {1**A2||0}||fp6}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- x9:{List {1**A3||0}||0} -> {List {1**A3||0}|len _v == len zs + len x9 && elems _v == elems zs + elems x9|0} <: x6:_ -> {List {1**A2||0}||fp6}
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
  A3 -> {1**a|U2|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, x9, xs, ys, z, zs xs == (Cons z zs) |- {1**a|U2|0} /\ {1**a|U1|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, x6, xs, ys, z, zs xs == (Cons z zs) |- {1**a|U2|0} <: {1**a|U1|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, x6, xs, ys, z, zs xs == (Cons z zs) |- {List|False|0} <: {List||0}
Constraints
  False ==> True
  ((U2 && xs == (Cons z zs)) && len xs >= 0) && len zs >= 0 ==> U1
QMap
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
  (((U1 && U2) && xs == (Cons z zs)) && len xs >= 0) && len zs >= 0
Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}] (10 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}] (10 0)

 
 Checking ys :: {List {1**A3||0}||fp14} in
\xs . \ys . 
    match xs with
      Cons z zs -> Cons z (append zs
                             ??)
from env with top-level potentials: Emptyset : 0,Nil : 0,xs : p51,ys : 0,z : p55,zs : p56 fp16
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- {List {m25**a||p54}|_v == ys|p53} <: {List {1**A3||0}||fp14}
stripping var: Var IntS "p53"
stripping var: Var IntS "fp14"
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
  A3 -> {1**a|U2|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- p53 >= fp14
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- {m25**a||p54} <: {1**a|U2|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- {List|False|p53} <: {List||0}
Constraints
  False ==> True
  (xs == (Cons z zs) && len xs >= 0) && len zs >= 0 ==> U2
QMap
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}] (10 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}] (10 0)

Generating resource constraints:
  p53 >= fp14 ~>
      p53 >= fp14
Solved resource constraint after conjoining formulas: SAT
    p53 >= fp14

 
 Checking append zs
            ys :: {List {1**A2||0}||fp6} in
\xs . \ys . 
    match xs with
      Cons z zs -> Cons z ??
from env with top-level potentials: Emptyset : 0,Nil : 0,xs : p23,ys : p25,z : p27,zs : p28 fp8
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- {List {1**A3||0}|len _v == len zs + len ys && elems _v == elems zs + elems ys|0} <: {List {1**A2||0}||fp6}
stripping int: IntLit 0
stripping var: Var IntS "fp6"
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
  A3 -> {1**a|U2|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, _v, append, xs, ys, z, zs xs == (Cons z zs) |- 0 >= fp6
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- {1**a|U2|0} <: {1**a|U1|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- {List|False|0} <: {List||0}
Constraints
  False ==> True
  ((U2 && xs == (Cons z zs)) && len xs >= 0) && len zs >= 0 ==> U1
QMap
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}] (10 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}] (10 0)

Generating resource constraints:
  0 >= fp6 ~>
      0 >= fp6
Solved resource constraint after conjoining formulas: SAT
    0 >= fp6

 
 Checking Cons z (append zs
                    ys) :: {List {1**a||0}|len _v == len xs + len ys && elems _v == elems xs + elems ys|0} in
\xs . \ys . 
    match xs with
      Cons z zs -> ??
from env with top-level potentials: Emptyset : 0,Nil : 0,xs : p12,ys : p13,z : p14,zs : p15 fp4
Typing Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, xs, ys, z, zs xs == (Cons z zs) |- LET x5:({List {0**A3||0}|len _v == len zs + len ys && elems _v == elems zs + elems ys|0}) IN {List {1**A2||0}|_v == (Cons z x5)|0} <: {List {1**a||0}|len _v == len xs + len ys && elems _v == elems xs + elems ys|0}
Type assignment
  A0 -> {m0**a||p1}
  A1 -> {m0**a||p1}
  A2 -> {1**a|U1|0}
  A3 -> {1**a|U2|0}
Pred assignment
Simple Constraints
    Cons, Emptyset, Insert, Nil, Singleton, append, x5, xs, ys, z, zs xs == (Cons z zs) |- {1**a|False|0} <: {1**a||0}
    Cons, Emptyset, Insert, Nil, Singleton, append, x5, xs, ys, z, zs xs == (Cons z zs) |- {List|elems _v == [z] + elems x5|0} <: {List|elems _v == elems xs + elems ys|0}
    Cons, Emptyset, Insert, Nil, Singleton, append, x5, xs, ys, z, zs xs == (Cons z zs) |- {List|len _v == 1 + len x5|0} <: {List|len _v == len xs + len ys|0}
Constraints
  (((((xs == (Cons z zs) && len _v == 1 + len x5) && len x5 >= 0) && len xs >= 0) && len ys >= 0) && len zs >= 0) && (len x5 == len zs + len ys && elems x5 == elems zs + elems ys) ==> len _v == len xs + len ys
  (((((xs == (Cons z zs) && elems _v == [z] + elems x5) && len x5 >= 0) && len xs >= 0) && len ys >= 0) && len zs >= 0) && (len x5 == len zs + len ys && elems x5 == elems zs + elems ys) ==> elems _v == elems xs + elems ys
  False ==> True
QMap
  U0 -> {}
  U1 -> {}
  U2 -> {}
Checking consistency
Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}] (12 0)
Remaining Candidates (1)
  0: [U0 -> {}, U1 -> {}, U2 -> {}] (12 0)
